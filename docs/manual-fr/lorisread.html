<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>lorisread</title>
    <link rel="stylesheet" type="text/css" href="csound.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.78.1" />
    <link rel="home" href="index.html" title="Manuel de référence canonique de Csound" />
    <link rel="up" href="OpcodesTop.html" title="Opcodes et opérateurs de l'orchestre" />
    <link rel="prev" href="lorenz.html" title="lorenz" />
    <link rel="next" href="lorismorph.html" title="lorismorph" />
  </head>
  <body>
    <div class="navheader">
      <table width="100%" summary="Navigation header">
        <tr>
          <th colspan="3" align="center">lorisread</th>
        </tr>
        <tr>
          <td width="20%" align="left"><a accesskey="p" href="lorenz.html">Précédent</a> </td>
          <th width="60%" align="center">Opcodes et opérateurs de l'orchestre</th>
          <td width="20%" align="right"> <a accesskey="n" href="lorismorph.html">Suivant</a></td>
        </tr>
      </table>
      <hr />
    </div>
    <div class="refentry">
      <a id="lorisread"></a>
      <div class="titlepage"></div>
      <a id="IndexLorisRead" class="indexterm"></a>
      <div class="refnamediv">
        <h2>
          <span class="refentrytitle">lorisread</span>
        </h2>
        <p>lorisread — Importe un ensemble de partiels à largeur de bande améliorée
    depuis un fichier de données au format SDIF, leur applique des enveloppes
    de mise en forme de fréquence, d'amplitude et de largeur de bande au taux-k
    et stocke les partiels modifiés en mémoire.
    </p>
      </div>
      <div class="refsect1">
        <a id="idm47887663359216"></a>
        <h2>Syntaxe</h2>
        <pre class="synopsis"><span class="command"><strong>lorisread</strong></span> ktimpnt, ifilcod, istoreidx, kfreqenv, kampenv, kbwenv[, ifadetime]</pre>
      </div>
      <div class="refsect1">
        <a id="idm47887663357328"></a>
        <h2>Description</h2>
        <p>
      <span class="emphasis"><em>lorisread</em></span> importe un ensemble de partiels à largeur
      de bande améliorée depuis un fichier de données au format SDIF, leur
      applique des enveloppes de mise en forme de fréquence, d'amplitude et de
      largeur de bande au taux-k et stocke les partiels modifiés en mémoire.
    </p>
      </div>
      <div class="refsect1">
        <a id="idm47887663355200"></a>
        <h2>Initialisation</h2>
        <p>
      <span class="emphasis"><em>ifilcod </em></span> - nombre entier ou chaîne de caractères
      dénotant un fichier de contrôle dérivé de l'analyse d'un signal audio
      par réassignation de largeur de bande améliorée. Un nombre entier
      indique le suffixe d'un fichier loris.sdif (par exemple loris.sdif.1) ;
      une chaîne de caractères (entre guillemets) donne un nom de fichier,
      qui peut être un nom de chemin complet. Si ce n'est pas un nom de chemin
      complet, le fichier est d'abord cherché dans le répertoire courant, puis
      dans celui qui est donné par la variable d'environnement SADIR (si elle
      est définie). Le fichier de données de réassignation de largeur de bande
      améliorée contient des valeurs de points charnières de fréquence,
      d'amplitude, de caractère bruiteux et d'enveloppe de phase organisés
      pour une synthèse  additive à largeur de bande améliorée. Les données de
      contrôle doivent être conformes à l'un des formats SDIF existant.
    </p>
        <p>
      Loris stocke les partiels dans des trames SDIF RBEP. Chaque trame RBEP
      contient une matrice RBEP et chaque ligne d'une matrice RBEP décrit un
      point charnière d'un partiel de Loris. Une trame RBEL contenant une
      matrice RBEL qui décrit l'étiquetage des partiels peut précéder la
      première trame RBEP dans le fichier SDIF. Les définitions des trames et
      des matrices RBEP et RBEL sont inclues dans l'en-tête du fichier SDIF.
      En plus des trames RBEP, Loris peut également lire et écrire des trames
      SDIF 1TRC. Comme les trames 1TRC ne représentent pas une amélioration
      de largeur de bande ou les coordonnées temporelles exactes de points
      charnière de Loris, leur utilisation est déconseillée. Les possibilités
      1TRC sont fournies pour pouvoir échanger des données avec des programmes
      qui ne peuvent pas traiter les trames RBEP.
    </p>
        <p>
      <span class="emphasis"><em>istoreidx, ireadidx, isrcidx, itgtidx</em></span> sont des étiquettes
      qui identifient un ensemble stocké de partiels à largeur de bande améliorée.
      <span class="emphasis"><em>lorisread</em></span> importe les partiels depuis un fichier
      SDIF et les stocke avec l'étiquette entière <span class="emphasis"><em>istoreidx</em></span>.
      <span class="emphasis"><em>lorismorph</em></span> réalise un morphing des ensembles de partiels
      étiquetés <span class="emphasis"><em>isrcidx</em></span> et <span class="emphasis"><em>itgtidx</em></span>, et
      stocke les partiels résultants avec l'étiquette entière
      <span class="emphasis"><em>istoreidx</em></span>. <span class="emphasis"><em>lorisplay</em></span> restitue
      les partiels stockés avec l'étiquette <span class="emphasis"><em>ireadidx</em></span>. Les
      étiquettes ne sont utilisées qu'à l'initialisation de la note, et l'on
      peut les réutiliser sans coût supplémentaire ou bénéfice en efficacité,
      et sans introduire d'interaction entre les instruments ou leurs instances.
    </p>
        <p>
      <span class="emphasis"><em>ifadetime (facultatif)</em></span> - En général, les partiels
      exportés depuis Loris commencent et se terminent avec une amplitude non
      nulle. Afin d'éviter les artefacts, il est très souvent nécessaire de
      d'introduire et de terminer progressivement les partiels au lieu de les
      commencer et de les terminer de façon abrupte. Si <span class="emphasis"><em>ifadetime</em></span>
      est différent de zéro, les partiels ont une attaque progressive et une
      chute dégressive. Ceci est réalisé en ajoutant deux points charnière à
      chaque partiel : un <span class="emphasis"><em>ifadetime</em></span> secondes avant le
      début et un autre <span class="emphasis"><em>ifadetime</em></span> secondes après la fin.
      (Cependant, aucun point charnière n'est ajouté à une date inférieure à
      zéro. Si nécessaire, la durée de l'introduction progressive est
      raccourcie.) Les points charnière supplémentaires au début et à la fin
      du partiel auront respectivement la même fréquence et la même largeur de
      bande que celle du premier et du dernier point charnière du partiel mais
      leurs amplitudes seront nulles. La phase des nouveaux points charnière
      sera extrapolée pour préserver la cohérence de phase. Si aucune valeur
      n'est spécifiée, <span class="emphasis"><em>ifadetime</em></span> vaut par défaut zéro.
      Notez que la valeur de <span class="emphasis"><em>ifadetime</em></span> peut être approchée,
      car les enveloppes des paramètres des partiels sont échantillonnées au
      taux de contrôle (taux-k) et indexées par <span class="emphasis"><em>ktimpnt</em></span>
      (voir ci-dessous), et non pas en temps réel.
    </p>
      </div>
      <div class="refsect1">
        <a id="idm47887663337904"></a>
        <h2>Exécution</h2>
        <p>
      <span class="emphasis"><em>lorisread</em></span> lit des données pré-calculées d'analyse
      par réassignation de largeur de bande améliorée depuis un fichier stocké
      au format SDIF, comme décrit ci-dessus. L'écoulement du temps dans ce
      fichier est spécifié par <span class="emphasis"><em>ktimpnt</em></span> qui réprésente le
      temps en secondes. <span class="emphasis"><em>ktimpnt</em></span> doit toujours être positif
      mais peut avancer ou reculer dans le temps, être stationnaire ou discontinu,
      comme un pointeur dans le fichier d'analyse. <span class="emphasis"><em>kfreqenv</em></span>
      est un facteur de transposition au taux de contrôle, 1.5 transposant vers
      l'aigu d'une quinte juste, et 0.5 transposant vers le grave d'une octave.
      <span class="emphasis"><em>kampenv</em></span> est un facteur de mise à l'échelle au taux de
      contrôle qui est appliqué à toutes les enveloppes d'amplitude des partiels.
      <span class="emphasis"><em>kbwenv</em></span> est un facteur de mise à l'échelle au taux de
      contrôle qui est appliqué à toutes les enveloppes de largeur de bande ou
      de caractère bruiteux des partiels. Les données de partiel à largeur de
      bande améliorée sont stockées en mémoire avec une étiquette spécifiée pour
      un accès ultérieur par un autre générateur.
    </p>
      </div>
      <div class="refsect1">
        <a id="idm47887663331936"></a>
        <h2>Exemples</h2>
        <p>
      Voici un exemple de l'opcode lorisread. Il utilise le fichier
      <a class="ulink" href="examples/lorisread.csd" target="_top"><em class="citetitle">lorisread.csd</em></a>.
      </p>
        <div class="example">
          <a id="idm47887663330064"></a>
          <p class="title">
            <strong>Exemple 462. Exemple de l'opcode lorisread.</strong>
          </p>
          <div class="example-contents">
            <p>Voir les sections <a class="link" href="UsingRealTime.html" title="Audio en temps réel"><em class="citetitle">Audio en Temps Réel</em></a>
        et <a class="link" href="CommandFlags.html" title="Ligne de commande de Csound"><em class="citetitle">Options de la Ligne de Commande</em></a> pour plus
        d'information sur l'utilisation des options de la ligne de commande.</p>
            <div class="refsect1">
              <a id="idm47887517834336"></a>
              <pre class="programlisting">
<span class="csdtag">&lt;CsoundSynthesizer&gt;</span>
<span class="csdtag">&lt;CsOptions&gt;</span>
<span class="comment">; Select audio/midi flags here according to platform</span>
-odac      <span class="comment">;;;realtime audio out</span>
<span class="comment">;-iadc    ;;;uncomment -iadc if realtime audio input is needed too</span>
<span class="comment">; For Non-realtime ouput leave only the line below:</span>
<span class="comment">; -o lorisread.wav -W ;;; for file output any platform</span>
<span class="csdtag">&lt;/CsOptions&gt;</span>
<span class="csdtag">&lt;CsInstruments&gt;</span>

<span class="ohdr">sr</span> <span class="op">=</span> 44100
<span class="ohdr">ksmps</span> <span class="op">=</span> 32
<span class="ohdr">nchnls</span> <span class="op">=</span> 2
<span class="ohdr">0dbfs</span>  <span class="op">=</span> 1

<span class="comment">; Play the partials in clarinet.sdif from 0 to 3 sec with 1 ms fadetime</span>
<span class="comment">; and no frequency , amplitude, or bandwidth modification.</span>

<span class="oblock">instr</span> 1

ktime <span class="opc">linseg</span> 0, p3, 3			<span class="comment">; linear time function from 0 to 3 seconds</span>
      lorisread	ktime, "clarinet.sdif", 1, 1, 1, 1, .001
asig  lorisplay	1, 1, 1, 1
      <span class="opc">outs</span> asig, asig
<span class="oblock">endin</span>


<span class="comment">; Play the partials in clarinet.sdif from 0 to 3 sec with 1 ms fadetime</span>
<span class="comment">; adding tuning and vibrato, increasing the "breathiness" (noisiness) and overall</span>
<span class="comment">; amplitude, and adding a highpass filter.</span>

<span class="oblock">instr</span> 2

ktime <span class="opc">linseg</span> 0, p3, 3			<span class="comment">; linear time function from 0 to 3 seconds</span>
					<span class="comment">; compute frequency scale for tuning  </span>
ifscale	<span class="op">=</span> <span class="opc">cpspch</span>(p4)<span class="op">/</span><span class="opc">cpspch</span>(8.08)	<span class="comment">; (original pitch was G#4)</span>
					<span class="comment">; make a vibrato envelope</span>
kvenv  <span class="opc">linseg</span> 0, p3<span class="op">/</span>6, 0, p3<span class="op">/</span>6, .02, p3<span class="op">/</span>3, .02, p3<span class="op">/</span>6, 0, p3<span class="op">/</span>6, 0
kvib   <span class="opc">oscil</span>  kvenv, 4, 1		<span class="comment">; table 1, sinusoid</span>
kbwenv <span class="opc">linseg</span> 1, p3<span class="op">/</span>6, 1, p3<span class="op">/</span>6, 2, 2<span class="op">*</span>p3<span class="op">/</span>3, 2	<span class="comment">;lots of noise</span>
       lorisread ktime, "clarinet.sdif", 1, 1, 1, 1, .001
a1     lorisplay 1, ifscale<span class="op">+</span>kvib, 2, kbwenv
asig   <span class="opc">atone</span> a1, 1000			<span class="comment">; highpass filter, cutoff 1000 Hz</span>
       <span class="opc">outs</span>  asig, asig
<span class="oblock">endin</span>

<span class="csdtag">&lt;/CsInstruments&gt;</span>
<span class="csdtag">&lt;CsScore&gt;</span>
<span class="comment">; a sinus</span>
<span class="stamnt">f</span> 1 0 4096 10 1

<span class="stamnt">i</span> 1    0      3
<span class="stamnt">i</span> 1    +      1
<span class="stamnt">i</span> 1    +      6
<span class="stamnt">s</span>

<span class="comment">;                  pitch</span>
<span class="stamnt">i</span> 2      1    3    8.08
<span class="stamnt">i</span> 2      3.5  1    8.04
<span class="stamnt">i</span> 2      4    6    8.00
<span class="stamnt">i</span> 2      4    6    8.07
<span class="stamnt">e</span>
<span class="csdtag">&lt;/CsScore&gt;</span>
<span class="csdtag">&lt;/CsoundSynthesizer&gt;</span>
</pre>
            </div>
          </div>
        </div>
        <p><br class="example-break" />
    </p>
      </div>
      <div class="refsect1">
        <a id="idm47887663325696"></a>
        <h2>Crédits</h2>
        <p>
      Cette implémentation des générateurs unitaires Loris a été écrite par
      Kelly Fitz (<a class="ulink" href="mailto:loris@cerlsoundgroup.org" target="_top">loris@cerlsoundgroup.org</a>).
      Elle est modèlisée sur un prototype d'implémentation du générateur
      unitaire <span class="emphasis"><em>lorisplay</em></span> écrit par Corbin Champion, et
      basé sur la méthode de synthèse additive à largeur de bande améliorée et
      sur les algorithmes de métamorphose sonore implémentés dans la bibliothèque
      Loris pour la modélisation et la manipulation du son. Les opcodes ont été
      ensuite adaptés sous la forme d'un greffon de Csound 5 par Michael Gogins.
    </p>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td width="40%" align="left"><a accesskey="p" href="lorenz.html">Précédent</a> </td>
          <td width="20%" align="center">
            <a accesskey="u" href="OpcodesTop.html">Niveau supérieur</a>
          </td>
          <td width="40%" align="right"> <a accesskey="n" href="lorismorph.html">Suivant</a></td>
        </tr>
        <tr>
          <td width="40%" align="left" valign="top">lorenz </td>
          <td width="20%" align="center">
            <a accesskey="h" href="index.html">Sommaire</a>
          </td>
          <td width="40%" align="right" valign="top"> lorismorph</td>
        </tr>
      </table>
    </div>
  </body>
</html>
